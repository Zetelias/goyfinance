// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package goyfinance

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonEc607727DecodeGithubComZeteliasGoyfinance(in *jlexer.Lexer, out *Quote) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "Ticker":
			out.Ticker = string(in.String())
		case "PriceRangeStart":
			out.PriceRangeStart = int64(in.Int64())
		case "PriceRangeEnd":
			out.PriceRangeEnd = int64(in.Int64())
		case "Interval":
			out.Interval = Interval(in.String())
		case "PriceHistoric":
			if in.IsNull() {
				in.Skip()
				out.PriceHistoric = nil
			} else {
				in.Delim('[')
				if out.PriceHistoric == nil {
					if !in.IsDelim(']') {
						out.PriceHistoric = make([]PriceData, 0, 1)
					} else {
						out.PriceHistoric = []PriceData{}
					}
				} else {
					out.PriceHistoric = (out.PriceHistoric)[:0]
				}
				for !in.IsDelim(']') {
					var v1 PriceData
					(v1).UnmarshalEasyJSON(in)
					out.PriceHistoric = append(out.PriceHistoric, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727EncodeGithubComZeteliasGoyfinance(out *jwriter.Writer, in Quote) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"Ticker\":"
		out.RawString(prefix[1:])
		out.String(string(in.Ticker))
	}
	{
		const prefix string = ",\"PriceRangeStart\":"
		out.RawString(prefix)
		out.Int64(int64(in.PriceRangeStart))
	}
	{
		const prefix string = ",\"PriceRangeEnd\":"
		out.RawString(prefix)
		out.Int64(int64(in.PriceRangeEnd))
	}
	{
		const prefix string = ",\"Interval\":"
		out.RawString(prefix)
		out.String(string(in.Interval))
	}
	{
		const prefix string = ",\"PriceHistoric\":"
		out.RawString(prefix)
		if in.PriceHistoric == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.PriceHistoric {
				if v2 > 0 {
					out.RawByte(',')
				}
				(v3).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Quote) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonEc607727EncodeGithubComZeteliasGoyfinance(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Quote) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonEc607727EncodeGithubComZeteliasGoyfinance(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Quote) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonEc607727DecodeGithubComZeteliasGoyfinance(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Quote) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonEc607727DecodeGithubComZeteliasGoyfinance(l, v)
}
func easyjsonEc607727DecodeGithubComZeteliasGoyfinance1(in *jlexer.Lexer, out *PriceData) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "OpenPrice":
			out.OpenPrice = float64(in.Float64())
		case "LowPrice":
			out.LowPrice = float64(in.Float64())
		case "HighPrice":
			out.HighPrice = float64(in.Float64())
		case "ClosePrice":
			out.ClosePrice = float64(in.Float64())
		case "Volume":
			out.Volume = int(in.Int())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727EncodeGithubComZeteliasGoyfinance1(out *jwriter.Writer, in PriceData) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"OpenPrice\":"
		out.RawString(prefix[1:])
		out.Float64(float64(in.OpenPrice))
	}
	{
		const prefix string = ",\"LowPrice\":"
		out.RawString(prefix)
		out.Float64(float64(in.LowPrice))
	}
	{
		const prefix string = ",\"HighPrice\":"
		out.RawString(prefix)
		out.Float64(float64(in.HighPrice))
	}
	{
		const prefix string = ",\"ClosePrice\":"
		out.RawString(prefix)
		out.Float64(float64(in.ClosePrice))
	}
	{
		const prefix string = ",\"Volume\":"
		out.RawString(prefix)
		out.Int(int(in.Volume))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v PriceData) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonEc607727EncodeGithubComZeteliasGoyfinance1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v PriceData) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonEc607727EncodeGithubComZeteliasGoyfinance1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *PriceData) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonEc607727DecodeGithubComZeteliasGoyfinance1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *PriceData) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonEc607727DecodeGithubComZeteliasGoyfinance1(l, v)
}
func easyjsonEc607727DecodeGithubComZeteliasGoyfinance2(in *jlexer.Lexer, out *JSONQuote) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "chart":
			easyjsonEc607727Decode(in, &out.Chart)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727EncodeGithubComZeteliasGoyfinance2(out *jwriter.Writer, in JSONQuote) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"chart\":"
		out.RawString(prefix[1:])
		easyjsonEc607727Encode(out, in.Chart)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v JSONQuote) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonEc607727EncodeGithubComZeteliasGoyfinance2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v JSONQuote) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonEc607727EncodeGithubComZeteliasGoyfinance2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *JSONQuote) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonEc607727DecodeGithubComZeteliasGoyfinance2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *JSONQuote) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonEc607727DecodeGithubComZeteliasGoyfinance2(l, v)
}
func easyjsonEc607727Decode(in *jlexer.Lexer, out *struct {
	Result []struct {
		Meta struct {
			Currency             string  `json:"currency"`
			Symbol               string  `json:"symbol"`
			ExchangeName         string  `json:"exchangeName"`
			InstrumentType       string  `json:"instrumentType"`
			FirstTradeDate       int     `json:"firstTradeDate"`
			RegularMarketTime    int     `json:"regularMarketTime"`
			Gmtoffset            int     `json:"gmtoffset"`
			Timezone             string  `json:"timezone"`
			ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
			RegularMarketPrice   float64 `json:"regularMarketPrice"`
			ChartPreviousClose   float64 `json:"chartPreviousClose"`
			PreviousClose        float64 `json:"previousClose"`
			Scale                int     `json:"scale"`
			PriceHint            int     `json:"priceHint"`
			CurrentTradingPeriod struct {
				Pre struct {
					Timezone  string `json:"timezone"`
					Start     int    `json:"start"`
					End       int    `json:"end"`
					Gmtoffset int    `json:"gmtoffset"`
				} `json:"pre"`
				Regular struct {
					Timezone  string `json:"timezone"`
					Start     int    `json:"start"`
					End       int    `json:"end"`
					Gmtoffset int    `json:"gmtoffset"`
				} `json:"regular"`
				Post struct {
					Timezone  string `json:"timezone"`
					Start     int    `json:"start"`
					End       int    `json:"end"`
					Gmtoffset int    `json:"gmtoffset"`
				} `json:"post"`
			} `json:"currentTradingPeriod"`
			TradingPeriods [][]struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"tradingPeriods"`
			DataGranularity string   `json:"dataGranularity"`
			Range           string   `json:"range"`
			ValidRanges     []string `json:"validRanges"`
		} `json:"meta"`
		Timestamp  []int `json:"timestamp"`
		Indicators struct {
			Quote []struct {
				Open   []float64 `json:"open"`
				Low    []float64 `json:"low"`
				Volume []int     `json:"volume"`
				High   []float64 `json:"high"`
				Close  []float64 `json:"close"`
			} `json:"quote"`
		} `json:"indicators"`
	} `json:"result"`
	Error interface{} `json:"error"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "result":
			if in.IsNull() {
				in.Skip()
				out.Result = nil
			} else {
				in.Delim('[')
				if out.Result == nil {
					if !in.IsDelim(']') {
						out.Result = make([]struct {
							Meta struct {
								Currency             string  `json:"currency"`
								Symbol               string  `json:"symbol"`
								ExchangeName         string  `json:"exchangeName"`
								InstrumentType       string  `json:"instrumentType"`
								FirstTradeDate       int     `json:"firstTradeDate"`
								RegularMarketTime    int     `json:"regularMarketTime"`
								Gmtoffset            int     `json:"gmtoffset"`
								Timezone             string  `json:"timezone"`
								ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
								RegularMarketPrice   float64 `json:"regularMarketPrice"`
								ChartPreviousClose   float64 `json:"chartPreviousClose"`
								PreviousClose        float64 `json:"previousClose"`
								Scale                int     `json:"scale"`
								PriceHint            int     `json:"priceHint"`
								CurrentTradingPeriod struct {
									Pre struct {
										Timezone  string `json:"timezone"`
										Start     int    `json:"start"`
										End       int    `json:"end"`
										Gmtoffset int    `json:"gmtoffset"`
									} `json:"pre"`
									Regular struct {
										Timezone  string `json:"timezone"`
										Start     int    `json:"start"`
										End       int    `json:"end"`
										Gmtoffset int    `json:"gmtoffset"`
									} `json:"regular"`
									Post struct {
										Timezone  string `json:"timezone"`
										Start     int    `json:"start"`
										End       int    `json:"end"`
										Gmtoffset int    `json:"gmtoffset"`
									} `json:"post"`
								} `json:"currentTradingPeriod"`
								TradingPeriods [][]struct {
									Timezone  string `json:"timezone"`
									Start     int    `json:"start"`
									End       int    `json:"end"`
									Gmtoffset int    `json:"gmtoffset"`
								} `json:"tradingPeriods"`
								DataGranularity string   `json:"dataGranularity"`
								Range           string   `json:"range"`
								ValidRanges     []string `json:"validRanges"`
							} `json:"meta"`
							Timestamp  []int `json:"timestamp"`
							Indicators struct {
								Quote []struct {
									Open   []float64 `json:"open"`
									Low    []float64 `json:"low"`
									Volume []int     `json:"volume"`
									High   []float64 `json:"high"`
									Close  []float64 `json:"close"`
								} `json:"quote"`
							} `json:"indicators"`
						}, 0, 0)
					} else {
						out.Result = []struct {
							Meta struct {
								Currency             string  `json:"currency"`
								Symbol               string  `json:"symbol"`
								ExchangeName         string  `json:"exchangeName"`
								InstrumentType       string  `json:"instrumentType"`
								FirstTradeDate       int     `json:"firstTradeDate"`
								RegularMarketTime    int     `json:"regularMarketTime"`
								Gmtoffset            int     `json:"gmtoffset"`
								Timezone             string  `json:"timezone"`
								ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
								RegularMarketPrice   float64 `json:"regularMarketPrice"`
								ChartPreviousClose   float64 `json:"chartPreviousClose"`
								PreviousClose        float64 `json:"previousClose"`
								Scale                int     `json:"scale"`
								PriceHint            int     `json:"priceHint"`
								CurrentTradingPeriod struct {
									Pre struct {
										Timezone  string `json:"timezone"`
										Start     int    `json:"start"`
										End       int    `json:"end"`
										Gmtoffset int    `json:"gmtoffset"`
									} `json:"pre"`
									Regular struct {
										Timezone  string `json:"timezone"`
										Start     int    `json:"start"`
										End       int    `json:"end"`
										Gmtoffset int    `json:"gmtoffset"`
									} `json:"regular"`
									Post struct {
										Timezone  string `json:"timezone"`
										Start     int    `json:"start"`
										End       int    `json:"end"`
										Gmtoffset int    `json:"gmtoffset"`
									} `json:"post"`
								} `json:"currentTradingPeriod"`
								TradingPeriods [][]struct {
									Timezone  string `json:"timezone"`
									Start     int    `json:"start"`
									End       int    `json:"end"`
									Gmtoffset int    `json:"gmtoffset"`
								} `json:"tradingPeriods"`
								DataGranularity string   `json:"dataGranularity"`
								Range           string   `json:"range"`
								ValidRanges     []string `json:"validRanges"`
							} `json:"meta"`
							Timestamp  []int `json:"timestamp"`
							Indicators struct {
								Quote []struct {
									Open   []float64 `json:"open"`
									Low    []float64 `json:"low"`
									Volume []int     `json:"volume"`
									High   []float64 `json:"high"`
									Close  []float64 `json:"close"`
								} `json:"quote"`
							} `json:"indicators"`
						}{}
					}
				} else {
					out.Result = (out.Result)[:0]
				}
				for !in.IsDelim(']') {
					var v4 struct {
						Meta struct {
							Currency             string  `json:"currency"`
							Symbol               string  `json:"symbol"`
							ExchangeName         string  `json:"exchangeName"`
							InstrumentType       string  `json:"instrumentType"`
							FirstTradeDate       int     `json:"firstTradeDate"`
							RegularMarketTime    int     `json:"regularMarketTime"`
							Gmtoffset            int     `json:"gmtoffset"`
							Timezone             string  `json:"timezone"`
							ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
							RegularMarketPrice   float64 `json:"regularMarketPrice"`
							ChartPreviousClose   float64 `json:"chartPreviousClose"`
							PreviousClose        float64 `json:"previousClose"`
							Scale                int     `json:"scale"`
							PriceHint            int     `json:"priceHint"`
							CurrentTradingPeriod struct {
								Pre struct {
									Timezone  string `json:"timezone"`
									Start     int    `json:"start"`
									End       int    `json:"end"`
									Gmtoffset int    `json:"gmtoffset"`
								} `json:"pre"`
								Regular struct {
									Timezone  string `json:"timezone"`
									Start     int    `json:"start"`
									End       int    `json:"end"`
									Gmtoffset int    `json:"gmtoffset"`
								} `json:"regular"`
								Post struct {
									Timezone  string `json:"timezone"`
									Start     int    `json:"start"`
									End       int    `json:"end"`
									Gmtoffset int    `json:"gmtoffset"`
								} `json:"post"`
							} `json:"currentTradingPeriod"`
							TradingPeriods [][]struct {
								Timezone  string `json:"timezone"`
								Start     int    `json:"start"`
								End       int    `json:"end"`
								Gmtoffset int    `json:"gmtoffset"`
							} `json:"tradingPeriods"`
							DataGranularity string   `json:"dataGranularity"`
							Range           string   `json:"range"`
							ValidRanges     []string `json:"validRanges"`
						} `json:"meta"`
						Timestamp  []int `json:"timestamp"`
						Indicators struct {
							Quote []struct {
								Open   []float64 `json:"open"`
								Low    []float64 `json:"low"`
								Volume []int     `json:"volume"`
								High   []float64 `json:"high"`
								Close  []float64 `json:"close"`
							} `json:"quote"`
						} `json:"indicators"`
					}
					easyjsonEc607727Decode1(in, &v4)
					out.Result = append(out.Result, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "error":
			if m, ok := out.Error.(easyjson.Unmarshaler); ok {
				m.UnmarshalEasyJSON(in)
			} else if m, ok := out.Error.(json.Unmarshaler); ok {
				_ = m.UnmarshalJSON(in.Raw())
			} else {
				out.Error = in.Interface()
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727Encode(out *jwriter.Writer, in struct {
	Result []struct {
		Meta struct {
			Currency             string  `json:"currency"`
			Symbol               string  `json:"symbol"`
			ExchangeName         string  `json:"exchangeName"`
			InstrumentType       string  `json:"instrumentType"`
			FirstTradeDate       int     `json:"firstTradeDate"`
			RegularMarketTime    int     `json:"regularMarketTime"`
			Gmtoffset            int     `json:"gmtoffset"`
			Timezone             string  `json:"timezone"`
			ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
			RegularMarketPrice   float64 `json:"regularMarketPrice"`
			ChartPreviousClose   float64 `json:"chartPreviousClose"`
			PreviousClose        float64 `json:"previousClose"`
			Scale                int     `json:"scale"`
			PriceHint            int     `json:"priceHint"`
			CurrentTradingPeriod struct {
				Pre struct {
					Timezone  string `json:"timezone"`
					Start     int    `json:"start"`
					End       int    `json:"end"`
					Gmtoffset int    `json:"gmtoffset"`
				} `json:"pre"`
				Regular struct {
					Timezone  string `json:"timezone"`
					Start     int    `json:"start"`
					End       int    `json:"end"`
					Gmtoffset int    `json:"gmtoffset"`
				} `json:"regular"`
				Post struct {
					Timezone  string `json:"timezone"`
					Start     int    `json:"start"`
					End       int    `json:"end"`
					Gmtoffset int    `json:"gmtoffset"`
				} `json:"post"`
			} `json:"currentTradingPeriod"`
			TradingPeriods [][]struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"tradingPeriods"`
			DataGranularity string   `json:"dataGranularity"`
			Range           string   `json:"range"`
			ValidRanges     []string `json:"validRanges"`
		} `json:"meta"`
		Timestamp  []int `json:"timestamp"`
		Indicators struct {
			Quote []struct {
				Open   []float64 `json:"open"`
				Low    []float64 `json:"low"`
				Volume []int     `json:"volume"`
				High   []float64 `json:"high"`
				Close  []float64 `json:"close"`
			} `json:"quote"`
		} `json:"indicators"`
	} `json:"result"`
	Error interface{} `json:"error"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"result\":"
		out.RawString(prefix[1:])
		if in.Result == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v5, v6 := range in.Result {
				if v5 > 0 {
					out.RawByte(',')
				}
				easyjsonEc607727Encode1(out, v6)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"error\":"
		out.RawString(prefix)
		if m, ok := in.Error.(easyjson.Marshaler); ok {
			m.MarshalEasyJSON(out)
		} else if m, ok := in.Error.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.Error))
		}
	}
	out.RawByte('}')
}
func easyjsonEc607727Decode1(in *jlexer.Lexer, out *struct {
	Meta struct {
		Currency             string  `json:"currency"`
		Symbol               string  `json:"symbol"`
		ExchangeName         string  `json:"exchangeName"`
		InstrumentType       string  `json:"instrumentType"`
		FirstTradeDate       int     `json:"firstTradeDate"`
		RegularMarketTime    int     `json:"regularMarketTime"`
		Gmtoffset            int     `json:"gmtoffset"`
		Timezone             string  `json:"timezone"`
		ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
		RegularMarketPrice   float64 `json:"regularMarketPrice"`
		ChartPreviousClose   float64 `json:"chartPreviousClose"`
		PreviousClose        float64 `json:"previousClose"`
		Scale                int     `json:"scale"`
		PriceHint            int     `json:"priceHint"`
		CurrentTradingPeriod struct {
			Pre struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"pre"`
			Regular struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"regular"`
			Post struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"post"`
		} `json:"currentTradingPeriod"`
		TradingPeriods [][]struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"tradingPeriods"`
		DataGranularity string   `json:"dataGranularity"`
		Range           string   `json:"range"`
		ValidRanges     []string `json:"validRanges"`
	} `json:"meta"`
	Timestamp  []int `json:"timestamp"`
	Indicators struct {
		Quote []struct {
			Open   []float64 `json:"open"`
			Low    []float64 `json:"low"`
			Volume []int     `json:"volume"`
			High   []float64 `json:"high"`
			Close  []float64 `json:"close"`
		} `json:"quote"`
	} `json:"indicators"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "meta":
			easyjsonEc607727Decode2(in, &out.Meta)
		case "timestamp":
			if in.IsNull() {
				in.Skip()
				out.Timestamp = nil
			} else {
				in.Delim('[')
				if out.Timestamp == nil {
					if !in.IsDelim(']') {
						out.Timestamp = make([]int, 0, 8)
					} else {
						out.Timestamp = []int{}
					}
				} else {
					out.Timestamp = (out.Timestamp)[:0]
				}
				for !in.IsDelim(']') {
					var v7 int
					v7 = int(in.Int())
					out.Timestamp = append(out.Timestamp, v7)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "indicators":
			easyjsonEc607727Decode3(in, &out.Indicators)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727Encode1(out *jwriter.Writer, in struct {
	Meta struct {
		Currency             string  `json:"currency"`
		Symbol               string  `json:"symbol"`
		ExchangeName         string  `json:"exchangeName"`
		InstrumentType       string  `json:"instrumentType"`
		FirstTradeDate       int     `json:"firstTradeDate"`
		RegularMarketTime    int     `json:"regularMarketTime"`
		Gmtoffset            int     `json:"gmtoffset"`
		Timezone             string  `json:"timezone"`
		ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
		RegularMarketPrice   float64 `json:"regularMarketPrice"`
		ChartPreviousClose   float64 `json:"chartPreviousClose"`
		PreviousClose        float64 `json:"previousClose"`
		Scale                int     `json:"scale"`
		PriceHint            int     `json:"priceHint"`
		CurrentTradingPeriod struct {
			Pre struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"pre"`
			Regular struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"regular"`
			Post struct {
				Timezone  string `json:"timezone"`
				Start     int    `json:"start"`
				End       int    `json:"end"`
				Gmtoffset int    `json:"gmtoffset"`
			} `json:"post"`
		} `json:"currentTradingPeriod"`
		TradingPeriods [][]struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"tradingPeriods"`
		DataGranularity string   `json:"dataGranularity"`
		Range           string   `json:"range"`
		ValidRanges     []string `json:"validRanges"`
	} `json:"meta"`
	Timestamp  []int `json:"timestamp"`
	Indicators struct {
		Quote []struct {
			Open   []float64 `json:"open"`
			Low    []float64 `json:"low"`
			Volume []int     `json:"volume"`
			High   []float64 `json:"high"`
			Close  []float64 `json:"close"`
		} `json:"quote"`
	} `json:"indicators"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"meta\":"
		out.RawString(prefix[1:])
		easyjsonEc607727Encode2(out, in.Meta)
	}
	{
		const prefix string = ",\"timestamp\":"
		out.RawString(prefix)
		if in.Timestamp == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v8, v9 := range in.Timestamp {
				if v8 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v9))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"indicators\":"
		out.RawString(prefix)
		easyjsonEc607727Encode3(out, in.Indicators)
	}
	out.RawByte('}')
}
func easyjsonEc607727Decode3(in *jlexer.Lexer, out *struct {
	Quote []struct {
		Open   []float64 `json:"open"`
		Low    []float64 `json:"low"`
		Volume []int     `json:"volume"`
		High   []float64 `json:"high"`
		Close  []float64 `json:"close"`
	} `json:"quote"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "quote":
			if in.IsNull() {
				in.Skip()
				out.Quote = nil
			} else {
				in.Delim('[')
				if out.Quote == nil {
					if !in.IsDelim(']') {
						out.Quote = make([]struct {
							Open   []float64 `json:"open"`
							Low    []float64 `json:"low"`
							Volume []int     `json:"volume"`
							High   []float64 `json:"high"`
							Close  []float64 `json:"close"`
						}, 0, 0)
					} else {
						out.Quote = []struct {
							Open   []float64 `json:"open"`
							Low    []float64 `json:"low"`
							Volume []int     `json:"volume"`
							High   []float64 `json:"high"`
							Close  []float64 `json:"close"`
						}{}
					}
				} else {
					out.Quote = (out.Quote)[:0]
				}
				for !in.IsDelim(']') {
					var v10 struct {
						Open   []float64 `json:"open"`
						Low    []float64 `json:"low"`
						Volume []int     `json:"volume"`
						High   []float64 `json:"high"`
						Close  []float64 `json:"close"`
					}
					easyjsonEc607727Decode4(in, &v10)
					out.Quote = append(out.Quote, v10)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727Encode3(out *jwriter.Writer, in struct {
	Quote []struct {
		Open   []float64 `json:"open"`
		Low    []float64 `json:"low"`
		Volume []int     `json:"volume"`
		High   []float64 `json:"high"`
		Close  []float64 `json:"close"`
	} `json:"quote"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"quote\":"
		out.RawString(prefix[1:])
		if in.Quote == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v11, v12 := range in.Quote {
				if v11 > 0 {
					out.RawByte(',')
				}
				easyjsonEc607727Encode4(out, v12)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjsonEc607727Decode4(in *jlexer.Lexer, out *struct {
	Open   []float64 `json:"open"`
	Low    []float64 `json:"low"`
	Volume []int     `json:"volume"`
	High   []float64 `json:"high"`
	Close  []float64 `json:"close"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "open":
			if in.IsNull() {
				in.Skip()
				out.Open = nil
			} else {
				in.Delim('[')
				if out.Open == nil {
					if !in.IsDelim(']') {
						out.Open = make([]float64, 0, 8)
					} else {
						out.Open = []float64{}
					}
				} else {
					out.Open = (out.Open)[:0]
				}
				for !in.IsDelim(']') {
					var v13 float64
					v13 = float64(in.Float64())
					out.Open = append(out.Open, v13)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "low":
			if in.IsNull() {
				in.Skip()
				out.Low = nil
			} else {
				in.Delim('[')
				if out.Low == nil {
					if !in.IsDelim(']') {
						out.Low = make([]float64, 0, 8)
					} else {
						out.Low = []float64{}
					}
				} else {
					out.Low = (out.Low)[:0]
				}
				for !in.IsDelim(']') {
					var v14 float64
					v14 = float64(in.Float64())
					out.Low = append(out.Low, v14)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "volume":
			if in.IsNull() {
				in.Skip()
				out.Volume = nil
			} else {
				in.Delim('[')
				if out.Volume == nil {
					if !in.IsDelim(']') {
						out.Volume = make([]int, 0, 8)
					} else {
						out.Volume = []int{}
					}
				} else {
					out.Volume = (out.Volume)[:0]
				}
				for !in.IsDelim(']') {
					var v15 int
					v15 = int(in.Int())
					out.Volume = append(out.Volume, v15)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "high":
			if in.IsNull() {
				in.Skip()
				out.High = nil
			} else {
				in.Delim('[')
				if out.High == nil {
					if !in.IsDelim(']') {
						out.High = make([]float64, 0, 8)
					} else {
						out.High = []float64{}
					}
				} else {
					out.High = (out.High)[:0]
				}
				for !in.IsDelim(']') {
					var v16 float64
					v16 = float64(in.Float64())
					out.High = append(out.High, v16)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "close":
			if in.IsNull() {
				in.Skip()
				out.Close = nil
			} else {
				in.Delim('[')
				if out.Close == nil {
					if !in.IsDelim(']') {
						out.Close = make([]float64, 0, 8)
					} else {
						out.Close = []float64{}
					}
				} else {
					out.Close = (out.Close)[:0]
				}
				for !in.IsDelim(']') {
					var v17 float64
					v17 = float64(in.Float64())
					out.Close = append(out.Close, v17)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727Encode4(out *jwriter.Writer, in struct {
	Open   []float64 `json:"open"`
	Low    []float64 `json:"low"`
	Volume []int     `json:"volume"`
	High   []float64 `json:"high"`
	Close  []float64 `json:"close"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"open\":"
		out.RawString(prefix[1:])
		if in.Open == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v18, v19 := range in.Open {
				if v18 > 0 {
					out.RawByte(',')
				}
				out.Float64(float64(v19))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"low\":"
		out.RawString(prefix)
		if in.Low == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v20, v21 := range in.Low {
				if v20 > 0 {
					out.RawByte(',')
				}
				out.Float64(float64(v21))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"volume\":"
		out.RawString(prefix)
		if in.Volume == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v22, v23 := range in.Volume {
				if v22 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v23))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"high\":"
		out.RawString(prefix)
		if in.High == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v24, v25 := range in.High {
				if v24 > 0 {
					out.RawByte(',')
				}
				out.Float64(float64(v25))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"close\":"
		out.RawString(prefix)
		if in.Close == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v26, v27 := range in.Close {
				if v26 > 0 {
					out.RawByte(',')
				}
				out.Float64(float64(v27))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjsonEc607727Decode2(in *jlexer.Lexer, out *struct {
	Currency             string  `json:"currency"`
	Symbol               string  `json:"symbol"`
	ExchangeName         string  `json:"exchangeName"`
	InstrumentType       string  `json:"instrumentType"`
	FirstTradeDate       int     `json:"firstTradeDate"`
	RegularMarketTime    int     `json:"regularMarketTime"`
	Gmtoffset            int     `json:"gmtoffset"`
	Timezone             string  `json:"timezone"`
	ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
	RegularMarketPrice   float64 `json:"regularMarketPrice"`
	ChartPreviousClose   float64 `json:"chartPreviousClose"`
	PreviousClose        float64 `json:"previousClose"`
	Scale                int     `json:"scale"`
	PriceHint            int     `json:"priceHint"`
	CurrentTradingPeriod struct {
		Pre struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"pre"`
		Regular struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"regular"`
		Post struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"post"`
	} `json:"currentTradingPeriod"`
	TradingPeriods [][]struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"tradingPeriods"`
	DataGranularity string   `json:"dataGranularity"`
	Range           string   `json:"range"`
	ValidRanges     []string `json:"validRanges"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "currency":
			out.Currency = string(in.String())
		case "symbol":
			out.Symbol = string(in.String())
		case "exchangeName":
			out.ExchangeName = string(in.String())
		case "instrumentType":
			out.InstrumentType = string(in.String())
		case "firstTradeDate":
			out.FirstTradeDate = int(in.Int())
		case "regularMarketTime":
			out.RegularMarketTime = int(in.Int())
		case "gmtoffset":
			out.Gmtoffset = int(in.Int())
		case "timezone":
			out.Timezone = string(in.String())
		case "exchangeTimezoneName":
			out.ExchangeTimezoneName = string(in.String())
		case "regularMarketPrice":
			out.RegularMarketPrice = float64(in.Float64())
		case "chartPreviousClose":
			out.ChartPreviousClose = float64(in.Float64())
		case "previousClose":
			out.PreviousClose = float64(in.Float64())
		case "scale":
			out.Scale = int(in.Int())
		case "priceHint":
			out.PriceHint = int(in.Int())
		case "currentTradingPeriod":
			easyjsonEc607727Decode5(in, &out.CurrentTradingPeriod)
		case "tradingPeriods":
			if in.IsNull() {
				in.Skip()
				out.TradingPeriods = nil
			} else {
				in.Delim('[')
				if out.TradingPeriods == nil {
					if !in.IsDelim(']') {
						out.TradingPeriods = make([][]struct {
							Timezone  string `json:"timezone"`
							Start     int    `json:"start"`
							End       int    `json:"end"`
							Gmtoffset int    `json:"gmtoffset"`
						}, 0, 2)
					} else {
						out.TradingPeriods = [][]struct {
							Timezone  string `json:"timezone"`
							Start     int    `json:"start"`
							End       int    `json:"end"`
							Gmtoffset int    `json:"gmtoffset"`
						}{}
					}
				} else {
					out.TradingPeriods = (out.TradingPeriods)[:0]
				}
				for !in.IsDelim(']') {
					var v28 []struct {
						Timezone  string `json:"timezone"`
						Start     int    `json:"start"`
						End       int    `json:"end"`
						Gmtoffset int    `json:"gmtoffset"`
					}
					if in.IsNull() {
						in.Skip()
						v28 = nil
					} else {
						in.Delim('[')
						if v28 == nil {
							if !in.IsDelim(']') {
								v28 = make([]struct {
									Timezone  string `json:"timezone"`
									Start     int    `json:"start"`
									End       int    `json:"end"`
									Gmtoffset int    `json:"gmtoffset"`
								}, 0, 1)
							} else {
								v28 = []struct {
									Timezone  string `json:"timezone"`
									Start     int    `json:"start"`
									End       int    `json:"end"`
									Gmtoffset int    `json:"gmtoffset"`
								}{}
							}
						} else {
							v28 = (v28)[:0]
						}
						for !in.IsDelim(']') {
							var v29 struct {
								Timezone  string `json:"timezone"`
								Start     int    `json:"start"`
								End       int    `json:"end"`
								Gmtoffset int    `json:"gmtoffset"`
							}
							easyjsonEc607727Decode6(in, &v29)
							v28 = append(v28, v29)
							in.WantComma()
						}
						in.Delim(']')
					}
					out.TradingPeriods = append(out.TradingPeriods, v28)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "dataGranularity":
			out.DataGranularity = string(in.String())
		case "range":
			out.Range = string(in.String())
		case "validRanges":
			if in.IsNull() {
				in.Skip()
				out.ValidRanges = nil
			} else {
				in.Delim('[')
				if out.ValidRanges == nil {
					if !in.IsDelim(']') {
						out.ValidRanges = make([]string, 0, 4)
					} else {
						out.ValidRanges = []string{}
					}
				} else {
					out.ValidRanges = (out.ValidRanges)[:0]
				}
				for !in.IsDelim(']') {
					var v30 string
					v30 = string(in.String())
					out.ValidRanges = append(out.ValidRanges, v30)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727Encode2(out *jwriter.Writer, in struct {
	Currency             string  `json:"currency"`
	Symbol               string  `json:"symbol"`
	ExchangeName         string  `json:"exchangeName"`
	InstrumentType       string  `json:"instrumentType"`
	FirstTradeDate       int     `json:"firstTradeDate"`
	RegularMarketTime    int     `json:"regularMarketTime"`
	Gmtoffset            int     `json:"gmtoffset"`
	Timezone             string  `json:"timezone"`
	ExchangeTimezoneName string  `json:"exchangeTimezoneName"`
	RegularMarketPrice   float64 `json:"regularMarketPrice"`
	ChartPreviousClose   float64 `json:"chartPreviousClose"`
	PreviousClose        float64 `json:"previousClose"`
	Scale                int     `json:"scale"`
	PriceHint            int     `json:"priceHint"`
	CurrentTradingPeriod struct {
		Pre struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"pre"`
		Regular struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"regular"`
		Post struct {
			Timezone  string `json:"timezone"`
			Start     int    `json:"start"`
			End       int    `json:"end"`
			Gmtoffset int    `json:"gmtoffset"`
		} `json:"post"`
	} `json:"currentTradingPeriod"`
	TradingPeriods [][]struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"tradingPeriods"`
	DataGranularity string   `json:"dataGranularity"`
	Range           string   `json:"range"`
	ValidRanges     []string `json:"validRanges"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"currency\":"
		out.RawString(prefix[1:])
		out.String(string(in.Currency))
	}
	{
		const prefix string = ",\"symbol\":"
		out.RawString(prefix)
		out.String(string(in.Symbol))
	}
	{
		const prefix string = ",\"exchangeName\":"
		out.RawString(prefix)
		out.String(string(in.ExchangeName))
	}
	{
		const prefix string = ",\"instrumentType\":"
		out.RawString(prefix)
		out.String(string(in.InstrumentType))
	}
	{
		const prefix string = ",\"firstTradeDate\":"
		out.RawString(prefix)
		out.Int(int(in.FirstTradeDate))
	}
	{
		const prefix string = ",\"regularMarketTime\":"
		out.RawString(prefix)
		out.Int(int(in.RegularMarketTime))
	}
	{
		const prefix string = ",\"gmtoffset\":"
		out.RawString(prefix)
		out.Int(int(in.Gmtoffset))
	}
	{
		const prefix string = ",\"timezone\":"
		out.RawString(prefix)
		out.String(string(in.Timezone))
	}
	{
		const prefix string = ",\"exchangeTimezoneName\":"
		out.RawString(prefix)
		out.String(string(in.ExchangeTimezoneName))
	}
	{
		const prefix string = ",\"regularMarketPrice\":"
		out.RawString(prefix)
		out.Float64(float64(in.RegularMarketPrice))
	}
	{
		const prefix string = ",\"chartPreviousClose\":"
		out.RawString(prefix)
		out.Float64(float64(in.ChartPreviousClose))
	}
	{
		const prefix string = ",\"previousClose\":"
		out.RawString(prefix)
		out.Float64(float64(in.PreviousClose))
	}
	{
		const prefix string = ",\"scale\":"
		out.RawString(prefix)
		out.Int(int(in.Scale))
	}
	{
		const prefix string = ",\"priceHint\":"
		out.RawString(prefix)
		out.Int(int(in.PriceHint))
	}
	{
		const prefix string = ",\"currentTradingPeriod\":"
		out.RawString(prefix)
		easyjsonEc607727Encode5(out, in.CurrentTradingPeriod)
	}
	{
		const prefix string = ",\"tradingPeriods\":"
		out.RawString(prefix)
		if in.TradingPeriods == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v31, v32 := range in.TradingPeriods {
				if v31 > 0 {
					out.RawByte(',')
				}
				if v32 == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
					out.RawString("null")
				} else {
					out.RawByte('[')
					for v33, v34 := range v32 {
						if v33 > 0 {
							out.RawByte(',')
						}
						easyjsonEc607727Encode6(out, v34)
					}
					out.RawByte(']')
				}
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"dataGranularity\":"
		out.RawString(prefix)
		out.String(string(in.DataGranularity))
	}
	{
		const prefix string = ",\"range\":"
		out.RawString(prefix)
		out.String(string(in.Range))
	}
	{
		const prefix string = ",\"validRanges\":"
		out.RawString(prefix)
		if in.ValidRanges == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v35, v36 := range in.ValidRanges {
				if v35 > 0 {
					out.RawByte(',')
				}
				out.String(string(v36))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjsonEc607727Decode6(in *jlexer.Lexer, out *struct {
	Timezone  string `json:"timezone"`
	Start     int    `json:"start"`
	End       int    `json:"end"`
	Gmtoffset int    `json:"gmtoffset"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "timezone":
			out.Timezone = string(in.String())
		case "start":
			out.Start = int(in.Int())
		case "end":
			out.End = int(in.Int())
		case "gmtoffset":
			out.Gmtoffset = int(in.Int())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727Encode6(out *jwriter.Writer, in struct {
	Timezone  string `json:"timezone"`
	Start     int    `json:"start"`
	End       int    `json:"end"`
	Gmtoffset int    `json:"gmtoffset"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"timezone\":"
		out.RawString(prefix[1:])
		out.String(string(in.Timezone))
	}
	{
		const prefix string = ",\"start\":"
		out.RawString(prefix)
		out.Int(int(in.Start))
	}
	{
		const prefix string = ",\"end\":"
		out.RawString(prefix)
		out.Int(int(in.End))
	}
	{
		const prefix string = ",\"gmtoffset\":"
		out.RawString(prefix)
		out.Int(int(in.Gmtoffset))
	}
	out.RawByte('}')
}
func easyjsonEc607727Decode5(in *jlexer.Lexer, out *struct {
	Pre struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"pre"`
	Regular struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"regular"`
	Post struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"post"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "pre":
			easyjsonEc607727Decode6(in, &out.Pre)
		case "regular":
			easyjsonEc607727Decode6(in, &out.Regular)
		case "post":
			easyjsonEc607727Decode6(in, &out.Post)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc607727Encode5(out *jwriter.Writer, in struct {
	Pre struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"pre"`
	Regular struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"regular"`
	Post struct {
		Timezone  string `json:"timezone"`
		Start     int    `json:"start"`
		End       int    `json:"end"`
		Gmtoffset int    `json:"gmtoffset"`
	} `json:"post"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"pre\":"
		out.RawString(prefix[1:])
		easyjsonEc607727Encode6(out, in.Pre)
	}
	{
		const prefix string = ",\"regular\":"
		out.RawString(prefix)
		easyjsonEc607727Encode6(out, in.Regular)
	}
	{
		const prefix string = ",\"post\":"
		out.RawString(prefix)
		easyjsonEc607727Encode6(out, in.Post)
	}
	out.RawByte('}')
}
